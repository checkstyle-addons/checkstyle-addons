/*
 * Checkstyle-Addons - Additional Checkstyle checks
 * Copyright (C) 2015 Thomas Jensen, All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License, version 3, as published by the Free
 * Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this
 * program.  If not, see <http://www.gnu.org/licenses/>.
 */

import groovy.xml.MarkupBuilder;



public class GeneratePomFile extends DefaultTask
{
    public final File pomFile = new File(getTemporaryDir(), 'pom.xml');

    private String appendix = null;

    protected final List<Configuration> bundledConfigs = new ArrayList<>();


    public GeneratePomFile()
    {
        super();
        setGroup(PublishingPlugin.PUBLISH_TASK_GROUP);

        configure {
            inputs.property('groupId', project.group);
            inputs.property('artifactId', project.name);
            inputs.property('version', project.version);
            if (getAppendix() != null) {
                inputs.property('appendix', getAppendix());
            }
            inputs.property('name', project.ext.longName);
            inputs.property('description', project.description);
            inputs.property('url', project.ext.website);
            inputs.property('authorName', project.ext.authorName);
            inputs.property('orgName', project.ext.orgName);
            inputs.property('orgUrl', project.ext.orgUrl);
            inputs.property('github', project.ext.github);

            outputs.file(pomFile);
        }

        doLast {
            pomFile.getParentFile().mkdirs();
            createPom();
        }
    }


    protected void createPom()
    {
        def writer = new StringWriter();
        def printer = new IndentPrinter(writer, '    ', true);
        def xml = new MarkupBuilder(printer)
        xml.doubleQuotes = true;
        xml.mkp.xmlDeclaration(version: '1.0', encoding: 'UTF-8');
        String effectiveArtifactId = inputs.properties.artifactId;
        if (getAppendix() != null) {
            effectiveArtifactId += '-' + getAppendix();
        }

        xml.project(
            'xmlns': 'http://maven.apache.org/POM/4.0.0',
            'xsi:schemaLocation': 'http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd',
            'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance')
        {
            modelVersion('4.0.0');
            groupId(inputs.properties.groupId);
            artifactId(effectiveArtifactId);
            version([:], inputs.properties.version);        // empty map resolves overloading conflict
            name([:], inputs.properties.name);
            if (inputs.properties.classifier != null) {
                classifier([:], inputs.properties.classifier);
            }
            description([:], inputs.properties.description);
            url(inputs.properties.url);

            if (bundledConfigs.size() > 0) {
                dependencies {
                    for (final Configuration cfg : bundledConfigs) {
                        for (Dependency d : cfg.allDependencies) {
                            if (!(d instanceof ExternalDependency)) {
                                throw new GradleException('Incompatible dependency: ' + d);
                            }
                            final ExternalDependency jar = (ExternalDependency) d;

                            dependency {
                                groupId(jar.getGroup());
                                artifactId(jar.getName());
                                version([:], jar.getVersion());

                                final DependencyArtifact artifcat = jar.getArtifacts().getAt(0);
                                final String depClassifier = artifcat != null ? artifcat.getClassifier() : null;
                                if (depClassifier != null) {
                                    classifier([:], depClassifier);
                                }
                                scope('compile');
                            }
                        }
                    }
                }
            }

            inceptionYear('2015');

            licenses {
                license {
                    name([:], 'GNU General Public License, Version 3');
                    url('https://www.gnu.org/copyleft/gpl.html');
                }
            }
            developers {
                developer {
                    name([:], inputs.properties.authorName);
                    email('checkstyle@thomasjensen.com');
                }
            }
            organization {
                name([:], inputs.properties.orgName);
                url(inputs.properties.orgUrl);
            }
            scm {
                connection('scm:git:git@github.com:' + inputs.properties.github + '.git');
                developerConnection('scm:git:git@github.com:' + inputs.properties.github + '.git');
                url('git@github.com:' + inputs.properties.github + '.git');
            }
        }

        pomFile.withWriter('UTF-8') { it << writer.toString() };
    }


    public String getAppendix()
    {
        return this.appendix;
    }


    public setAppendix(final String pAppendix)
    {
        this.appendix = pAppendix;
        if (pAppendix != null) {
            inputs.property('appendix', pAppendix);
        }
        else {
            inputs.getProperties().remove('appendix');
        }
    }


    public void addBundledConfigs(final Configuration... pConfigs)
    {
        if (pConfigs != null && pConfigs.length > 0) {
            for (Configuration cfg : pConfigs) {
                if (cfg != null) {
                    boolean duplicate = false;
                    for (Configuration c : bundledConfigs) {
                        if (c.getName().equals(cfg.getName())) {
                            duplicate = true;
                            break;
                        }
                    }
                    if (!duplicate) {
                        bundledConfigs.add(cfg);
                    }
                }
            }
        }
    }
}
task generatePom(type: GeneratePomFile) {
    setDescription(project.ext.longName +
        ': Generates the Maven POM file for publication \'checkstyleAddons\' (no appendix).');
    addBundledConfigs(project.configurations['runtime']);
}



tasks.all { final Task pTask ->
    for (final Map.Entry<String, Map<String, String>> entry : tasks.depConfigs.publications) {
        final String pubNameCap = entry.getKey().capitalize();
        final Map<String, String> dvs = entry.getValue();

        // local publication depends on the pom.xml
        if (pTask.name.endsWith('PublicationToMavenLocal')) {
            final String taskName = "publish${pubNameCap}PublicationToMavenLocal";
            if (taskName.equals(pTask.name)) {
                pTask.dependsOn tasks['generatePom' + (dvs.Default ? '' : dvs.CsVersComp)];
            }
        }

        // the default task for POM creation is replaced by our own
        else if (pTask.name.startsWith('generatePomFileFor')) {
            final String taskName = "generatePomFileFor${pubNameCap}Publication";
            if (taskName.equals(pTask.name)) {
                pTask.enabled = false;  // we do this manually
                pTask.destination = new File(project.buildDir, 'tmp/generatePom' + (dvs.Default ? '' : dvs.CsVersComp) +
                    '/pom.xml');
            }
        }
    }
}



task checkProperties << {
    ['bintray.user', 'bintray.apikey', 'bintray.gpg.passphrase', 'sonatype.user', 'sonatype.password'].each {
        final String prp ->
        if (!project.hasProperty(prp)) {
            throw new GradleException("Could not find property \'${prp}\'. " +
                'Did you forget to specify it in ~/.gradle/gradle.properties?');
        }
    }
}

bintray {
    if (project.hasProperty('bintray.user') && project.hasProperty('bintray.apikey')
        && project.hasProperty('bintray.gpg.passphrase') && project.hasProperty('sonatype.user')
        && project.hasProperty('sonatype.password'))
    {
        user = project.property('bintray.user');
        key = project.property('bintray.apikey');

        Set<String> pubNames = tasks.depConfigs.publications.keySet();
        publications = pubNames.toArray(new String[pubNames.size()]);
        publish = true;
        //dryRun = true;   // comment out for actual release deployment
        pkg {
            repo = 'checkstyle-addons'
            userOrg = 'checkstyle-addons';
            name = project.name;
            desc = project.description;
            websiteUrl = project.ext.website;
            issueTrackerUrl = project.ext.issueTrackerUrl;
            vcsUrl = 'https://github.com/checkstyle-addons/checkstyle-addons.git';
            licenses = ['GPL-3.0'];
            publicDownloadNumbers = true;
            version {
                name = project.version;  // Bintray logical version name
                released = project.ext.buildTimestamp;
                vcsTag = 'v' + project.version;
                gpg {
                    sign = true;
                    passphrase = project.property('bintray.gpg.passphrase');
                }
                mavenCentralSync {
                    sync = true;
                    user = project.property('sonatype.user');
                    password = project.property('sonatype.password');
                }
            }
        }
    }
}
tasks['bintrayUpload'].dependsOn('checkProperties');

