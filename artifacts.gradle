/*
 * Checkstyle-Addons - Additional Checkstyle checks
 * Copyright (C) 2015 Thomas Jensen, All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License, version 3, as published by the Free
 * Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this
 * program.  If not, see <http://www.gnu.org/licenses/>.
 */
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.1.0';
    }
}

import org.ajoberstar.grgit.Grgit;
import org.apache.tools.ant.filters.ReplaceTokens;
import org.gradle.internal.jvm.Jvm;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.SimpleDateFormat;


/**
 * Scan the dependencies of the specified configurations and return a list of File objects for each dependency.
 * Resolves the configurations if they are still unresolved.
 * @param pProject the project
 * @param pIncludeCheckstyle flag indicating if the dependency on Checkstyle should be included in the result
 * @return list of files
 */
def Set<File> getPublishedDependencyLibs(final Project pProject, final boolean pIncludeCheckstyle)
{
    Set<File> result = new HashSet<>();
    for (final String configName : ext.bundledConfigurations) {
        Configuration cfg = pProject.configurations.getByName(configName);
        if (cfg == null) {
            throw new GradleScriptException("Unknown configuration: " + configName, null);
        }
        for (ResolvedDependency dep : cfg.getResolvedConfiguration().getFirstLevelModuleDependencies()) {
            if (pIncludeCheckstyle || !isCheckstyle(dep)) {
                for (ResolvedArtifact artifact : dep.allModuleArtifacts) {
                    result.add(artifact.file);
                }
            }
        }
    }
    return result;
}



def boolean isCheckstyle(final ResolvedDependency pDependency) {
    return pDependency != null && 'com.puppycrawl.tools'.equals(pDependency.getModuleGroup()) &&
        'checkstyle'.equals(pDependency.getModuleName());
}



def String flattenPrefixLibs(final String pPrefix, final Set<File> pLibs, final char pSeparator)
{
    Set<String> set = new HashSet<>();
    final String prefix = pPrefix.endsWith('/') ? pPrefix : (pPrefix + '/');
    for (final File f : pLibs) {
        set.add(prefix + f.getName());
    }
    StringBuilder sb = new StringBuilder();
    for (final Iterator<String> iter = set.iterator(); iter.hasNext();) {
        sb.append(iter.next());
        if (iter.hasNext()) {
            sb.append(pSeparator);
        }
    }
    return sb.toString();
}



def void buildPluginPomProps(final File pPomPropsFile)
{
    List<String> entries = new ArrayList<>();
    entries.add('#Generated by Maven');
    entries.add('#@buildTimestamp@');
    entries.add('groupId=' + project.group);
    entries.add('artifactId=' + project.name);
    entries.add('version=' + project.version);
    if (getCsaClassifier() != null) {
        entries.add('classifier=' + getCsaClassifier());
    }
    Files.write(pPomPropsFile.toPath(), entries, StandardCharsets.UTF_8);
}



def String getCsaClassifier()
{
    String result = 'cs' + project.ext.versions.Checkstyle;
    if (project.ext.depConfigDefault.equals(result)) {
        result = null;
    }
    return result;
}



model {
    tasks.jar {
        dependsOn project.tasks['generatePomFileForCheckstyleAddonsPublication'];

        classifier = getCsaClassifier();

        final File pluginPom = tasks.generatePomFileForCheckstyleAddonsPublication.destination;
        inputs.files pluginPom;

        File pluginPomProps = new File(getTemporaryDir(), 'pom.properties');
        buildPluginPomProps(pluginPomProps);
        outputs.files pluginPomProps;

        exclude '**/sonarqube/**';
        exclude 'sonarqube.xml';
        exclude '**/*.md';
        exclude '**/checks/all_checks.html';
        exclude 'eclipsecs-plugin.xml';
        exclude '**/checkstyle-metadata.*';

        into('META-INF') {
            from 'LICENSE';
        }

        manifest {
            attributes = ['Specification-Title'     : project.name,
                          'Specification-Vendor'    : project.ext.authorName,
                          'Specification-Vendor-Id' : 'com.thomasjensen',
                          'Specification-Version'   : project.version,
                          'Implementation-Title'    : project.name,
                          'Implementation-Vendor'   : project.ext.authorName,
                          'Implementation-Vendor-Id': 'com.thomasjensen',
                          'Implementation-Version'  : project.version,
                          'Implementation-Build'    : getGitHash(),
                          'Checkstyle-Version'      : project.ext.versions.Checkstyle,];
            attributes.putAll(mfAttrStd());
        }

        doFirst {
            // add generated POM to archive
            into('META-INF/maven/' + project.group + '/' + project.name) {
                from pluginPom;
                rename {String fileName -> fileName.replace('pom-default.xml', 'pom.xml');}
            }
            into('META-INF/maven/' + project.group + '/' + project.name) {
                from pluginPomProps;
                filter(ReplaceTokens, tokens: [buildTimestamp: project.ext.buildTimestamp.toString()]);
            }
            from(pluginPom) {
                rename {String fileName -> fileName.replace('pom-default.xml', 'pom.xml');}
            }

            // add build timestamp in execution phase so that it does not count for the up-to-date check
            manifest {
                attributes 'Build-Timestamp': project.ext.buildTimestamp.toString();
            }
        }
    }
}



task jarSources(type: Jar, dependsOn: classes) {
    // build sources JAR only for default Checkstyle version
    enabled = getCsaClassifier() == null;

    from sourceSets.main.allSource
    exclude '**/*.xml';
    exclude '**/*.html';
    exclude '**/*.md';
    exclude '**/checkstyle-metadata.*';
    into('META-INF') {
        from 'LICENSE';
    }

    classifier = 'sources';
    manifest = jar.manifest;
    doFirst {
        manifest {
            attributes 'Build-Timestamp': project.ext.buildTimestamp.toString();
        }
    }
}



task jarJavadoc(type: Jar, dependsOn: javadoc) {
    // build javadoc JAR only for default Checkstyle version
    enabled = getCsaClassifier() == null;

    from javadoc.destinationDir
    into('META-INF') {
        from 'LICENSE';
    }

    classifier = 'javadoc';
    manifest = jar.manifest;
    doFirst {
        manifest {
            attributes 'Build-Timestamp': project.ext.buildTimestamp.toString();
        }
    }
}



task jarEclipse(type: Jar, dependsOn: classes) {
    description = 'Checkstyle-Addons: Assembles the Eclipse-CS plugin';
    appendix = 'eclipse';
    classifier = getCsaClassifier();

    into('META-INF') {
        from 'LICENSE';
    }
    from(sourceSets.main.output) {
        exclude '**/sonarqube/**';
        exclude '**/sonarqube';
        exclude '**/*.md';
        exclude '**/checks/all_checks.html';
        exclude 'sonarqube.xml';
        exclude '**/checkstyle-metadata.*';
        rename { String fileName -> fileName.replace('eclipsecs-plugin.xml', 'plugin.xml'); }
    }
    from(sourceSets.main.output) {
        include '**/checkstyle-metadata.*';
        filter(ReplaceTokens, tokens: [version: project.version]);
    }
    Set<File> pubLibs = getPublishedDependencyLibs(project, false);
    into('lib') {
        from pubLibs;
    }

    manifest {
        attributes = [
            'Bundle-ManifestVersion': '2',
            'Bundle-Name': project.ext.longName +
                ' Eclipse-CS Extension (based on Checkstyle ' + project.ext.versions.Checkstyle + ')',
            'Bundle-SymbolicName': project.group + ';singleton:=true',
            'Bundle-Version': project.version,
            'Require-Bundle': 'net.sf.eclipsecs.checkstyle,' +
                'net.sf.eclipsecs.core,' + 'net.sf.eclipsecs.ui',
            'Bundle-RequiredExecutionEnvironment': 'JavaSE-' + project.ext.versions.Java,
            'Eclipse-LazyStart': 'true',
            'Bundle-Vendor': project.ext.authorName,
            'Import-Package': 'org.eclipse.core.resources,' +
                'org.eclipse.jdt.core.dom,' + 'org.eclipse.jface.resource,' + 'org.eclipse.jface.text,' +
                'org.eclipse.swt.graphics,' + 'org.eclipse.ui',
        ];
        attributes.putAll(mfAttrStd());
        if (pubLibs?.size() > 0) {
            attributes.put('Bundle-ClassPath', '.,' + flattenPrefixLibs('lib/', pubLibs, ','.toCharacter()));
        }
    }
    doFirst {
        manifest {
            attributes 'Build-Timestamp': project.ext.buildTimestamp.toString();
        }
    }
}



def String getGitHash() {
    def grgit = Grgit.open(project.file('.'));
    return grgit.head().id;
}



task jarSonarQube(type: Jar, dependsOn: jar) {
    description = 'Checkstyle-Addons: Assembles the SonarQube plugin';
    if ("NOT_SUPPORTED".equals(versions.SonarQube)) {
        enabled = false;
    }

    final String pluginKey = 'checkstyleaddons';
    archiveName = 'sonar-' + pluginKey + '-' + project.version +
            (getCsaClassifier() != null ? ('-' + getCsaClassifier()) : '') + '.jar';
    final File mainCheckJar = project.tasks['jar'].getProperties().get('archivePath');

    into('META-INF') {
        from 'LICENSE';
    }
    into(project.ext.sqPackage) {
        from(new File(sourceSets.main.output.classesDir, project.ext.sqPackage)) {
            include 'CheckstyleExtensionPlugin.class';
            include 'CheckstyleExtensionRepository.class';
        }
    }
    into(project.ext.sqPackage) {
        from new File(sourceSets.main.output.resourcesDir, 'sonarqube.xml');
        filter(ReplaceTokens, tokens: [version: project.version]);
    }
    into('META-INF/lib') {
        from mainCheckJar;
    }
    Set<File> pubLibs = getPublishedDependencyLibs(project, false);
    into('META-INF/lib') {
        from pubLibs;
    }

    manifest {
        attributes = [
            'Plugin-Name': project.ext.longName,
            'Plugin-Base': 'checkstyle',
            'Plugin-Key': pluginKey,
            'Implementation-Build': getGitHash(),
            'Plugin-Description': project.description + ' (based on Checkstyle ' +
                project.ext.versions.Checkstyle + ')',
            'Plugin-Version': project.version,
            'Plugin-Organization': project.ext.authorName,
            'Plugin-OrganizationUrl': project.ext.orgUrl,
            'Plugin-SourcesUrl': 'https://github.com/checkstyle-addons/checkstyle-addons',
            'Plugin-IssueTrackerUrl': project.ext.issueTrackerUrl,
            'Plugin-Class': 'com.thomasjensen.checkstyle.addons.sonarqube.CheckstyleExtensionPlugin',
            'Plugin-RequirePlugins': 'java:' + project.ext.versions.SQJavaPlugin +
                ',checkstyle:' + project.ext.versions.SQCheckstylePlugin,
            'Plugin-Dependencies': 'META-INF/lib/' + mainCheckJar.getName() + (pubLibs.size() > 0 ? ' ' : '') +
                flattenPrefixLibs('META-INF/lib/', pubLibs, ' '.toCharacter()),
            'Plugin-License': 'GPLv3',
            'Plugin-Homepage': project.ext.website,
            //'Plugin-TermsConditionsUrl': '',
            'Sonar-Version': project.ext.versions.SQManifest
            // TODO use same SonarQube version in manifest and compile dependencies
        ];
        attributes.putAll(mfAttrStd());
        attributes.remove('Website');
    }

    doFirst {
        final DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");  // required by SonarQube
        manifest {
            attributes 'Plugin-BuildDate': sdf.format(project.ext.buildTimestamp);
        }
    }
}


artifacts {
    archives jar
    if (getCsaClassifier() == null) {
        archives jarSources
        archives jarJavadoc
    }
    archives jarEclipse
    archives jarSonarQube
}


def Map<String, String> mfAttrStd() {
    Map<String, String> result = new HashMap<>();
    result.put('Manifest-Version', '1.0');
    result.put('Website', project.ext.website);
    result.put('Dependency-Configuration', project.ext.depConfig);
    result.put('Created-By', GradleVersion.current().toString());
    result.put('Built-By', System.getProperty('user.name'));
    result.put('Build-Jdk', Jvm.current());
    return result;
}
