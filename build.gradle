/*
 * Checkstyle-Addons - Additional Checkstyle checks
 * Copyright (C) 2015 Thomas Jensen, All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License, version 3, as published by the Free
 * Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this
 * program.  If not, see <http://www.gnu.org/licenses/>.
 */
buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.2.0';
    }
}

plugins {
    id 'java';
    id 'jacoco';
    id 'com.github.kt3k.coveralls' version '2.4.0';
    id 'checkstyle';
    id 'idea';
    id 'maven-publish';
    id 'com.jfrog.bintray' version '1.2';
    //id 'com.github.johnrengelman.shadow' version '1.2.1';
}

repositories {
    mavenLocal()
    jcenter()
    mavenCentral()
}

import com.thomasjensen.checkstyle.addons.build.ConfigNames;
import com.thomasjensen.checkstyle.addons.build.NameFactory;
import com.thomasjensen.checkstyle.addons.build.SourceSetNames;
import com.thomasjensen.checkstyle.addons.build.TaskNames;
import org.ajoberstar.grgit.Grgit;

group = 'com.thomasjensen.checkstyle.addons';
version = readVersionProps();
description = 'Additional Checkstyle Checks';
ext {
    depConfigDefault = 'cs6.4.1';   // MUST be one that supports SonarQube (for IDE compilation) + PUBLISHED
    // versionDefaults defined by DependencyConfigsTask
    bundledConfigurations = ['runtime'];
    defaultPublication = 'checkstyleAddons';   // name of the default Gradle publication
    jdk6PropName = 'checkstyleaddons_jdk6_javac';
    javadoc6PropName = 'checkstyleaddons_jdk6_javadoc';
    authorName = 'Thomas Jensen';
    longName = 'Checkstyle Addons';
    orgName = 'Checkstyle Addons';
    orgUrl = 'https://github.com/checkstyle-addons';
    github = 'checkstyle-addons/checkstyle-addons';
    issueTrackerUrl = "https://github.com/${github}/issues";
    buildTimestamp = new Date();
    sqPluginKey = 'checkstyleaddons';
    sqPackage = 'com/thomasjensen/checkstyle/addons/sonarqube';
    checksPackage = 'com/thomasjensen/checkstyle/addons/checks';
    website = 'http://checkstyle-addons.thomasjensen.com/';
    gitRepo = Grgit.open(project.file('.'));
    gitHash = gitRepo.head().id;
}


/*
 * Read all dependency configurations from 'project/dependencyConfigs' and make them available
 */
class DependencyConfigsTask extends DefaultTask
{
    private static final String PUB_INDICATOR = '.pub';

    protected final File depConfigDir = new File((File) project.projectDir, 'project/dependencyConfigs');

    public final FileCollection allDepConfigs = project.files {
        depConfigDir.listFiles(new FilenameFilter() {
            @Override
            boolean accept(final File pDir, final String pName) {
                return pName.endsWith('.properties');
            }
        });
    };

    /** map from dependency configuration names to their corresponding dependency versions */
    public final SortedMap<String, Map<String, String>> depVersions = readAllDependencyVersions(project, allDepConfigs);

    /** map from publication name to dependency versions for the corresponding dependency configuration */
    public final Map<String, Map<String, String>> publications = getPublicationList(project, depVersions);

    public final Set<String> activeDepConfigs = depVersions.keySet();


    private static Map<String, String> readDependencyVersions(final Project pProject, final File pDepConfig,
        final boolean pPublished)  // TODO should be Map<String, Object>
    {
        def props = new Properties();
        pDepConfig.withInputStream {
            InputStream stream -> props.load(stream);
        }

        if (props.getProperty('Description') != null) {
            props.remove('Description');
        }
        if (pPublished) {
            int expectedNumber = 9;
            if (props.getProperty('PublicationSuffix') != null) {
                expectedNumber++;
            }
            String testAgainstStr = props.getProperty('TestAgainst');
            if (testAgainstStr == null || props.size() != expectedNumber) {
                throw new GradleException('Broken dependency configuration: ' + pDepConfig.getName());
            }
            props.put('TestAgainst',
                Collections.unmodifiableSortedSet(new TreeSet<String>(Arrays.asList(testAgainstStr.split(',\\s*')))));
        }
        else {
            assert props.size() == 8;
        }
        props.put('Published', Boolean.valueOf(pPublished));
        props.put('Name', nameFromFile(pDepConfig));
        props.put('Default', Boolean.valueOf(pProject.ext.depConfigDefault.equals(props.getProperty('Name'))));

        return Collections.unmodifiableMap(new HashMap<>(props));
    }


    private static String nameFromFile(final File pDepConfigFile)
    {
        String result = null;
        int dotPos = pDepConfigFile.getName().lastIndexOf('.'.getAt(0));
        if (dotPos > 0) {
            if (pDepConfigFile.getName().substring(0, dotPos).endsWith(PUB_INDICATOR)) {
                dotPos -= PUB_INDICATOR.length();
            }
            result = pDepConfigFile.getName().substring(0, dotPos);
        }
        if (result == null || result.length() == 0) {
            throw new GradleException('Invalid dependency configuration file name: ' + pDepConfigFile.getName());
        }
        return result;
    }


    private static SortedMap<String, Map<String, String>> readAllDependencyVersions(final Project pProject,
        final FileCollection pAllDepConfigs)
    {
        SortedMap<String, Map<String, String>> result = new TreeMap<>();
        for (final File depCfg : pAllDepConfigs) {
            final String depConfName = nameFromFile(depCfg);
            final boolean published = depCfg.getName().substring(depConfName.length()).startsWith(PUB_INDICATOR);
            final Map<String, String> dvs = readDependencyVersions(pProject, depCfg, published);
            final String myJavaLevel = dvs.Java;
            if (!'1.6'.equals(myJavaLevel) || pProject.getJdk6Compiler() != null) {
                result.put(depConfName, dvs);
            } else {
                pProject.logger.warn('WARNING: Skipping dependency configuration \'' + depConfName +
                    '\' because of missing JDK6 compiler configuration.');
                pProject.logger.warn('Property \'' + pProject.ext.jdk6PropName + '\' not defined in gradle.' +
                    'properties. It must point to a Java 6 compiler executable.');
            }
        }
        return Collections.unmodifiableSortedMap(result);
    }


    private static Map<String, Map<String, String>> getPublicationList(final Project pProject,
        final SortedMap<String, Map<String, String>> pDepVersions)
    {
        final Map<String, Map<String, String>> result = new HashMap<>();
        for (final Map.Entry<String, Map<String, String>> entry : pDepVersions) {
            final String depConfName = entry.getKey();
            final Map<String, String> dvs = entry.getValue();
            if (dvs.Published) {
                String pubName = pProject.ext.defaultPublication;
                if (!pProject.ext.depConfigDefault.equals(depConfName)) {
                    pubName += '-' + dvs.PublicationSuffix;
                }
                result.put(pubName, dvs);
            }
        }
        return Collections.unmodifiableMap(result);
    }
}
task depConfigs(type: DependencyConfigsTask) {
    description = project.ext.longName + ': Read active dependency configurations from ' + depConfigDir;

    inputs.files allDepConfigs;

    project.ext.versionDefaults = depVersions.get(depConfigDefault);

    println "Dependency configurations found: ${activeDepConfigs}; default: ${project.ext.depConfigDefault}";
}

project.ext.nameFactory = new NameFactory(project,
    ((DependencyConfigsTask) tasks.depConfigs).depVersions.get(depConfigDefault).Checkstyle);



/*
 * Set up build for each dependency configuration
 */
tasks.depConfigs.activeDepConfigs.each { final String depCfg ->

    if (depConfigDefault.equals(depCfg)) {
        return;   // no extra stuff for the default config - important to make IDE configuration work
    }

    final Map<String, String> depVersions = ((DependencyConfigsTask) tasks.depConfigs).depVersions.get(depCfg);
    final String csVersion = depVersions.Checkstyle;
    final NameFactory nameFactory = project.ext.nameFactory;
    final boolean hasSonarQube = !"NOT_SUPPORTED".equals(depVersions.SonarQube);
    final boolean isPublished = depVersions.Published;
    final File depCfgFile = tasks.depConfigs.allDepConfigs.filter { final File f ->
        f.getName().startsWith(depCfg + '.p');
    }.getSingleFile();

    // 'main' sourceSet
    SourceSet mainSourceSet = project.sourceSets.create(nameFactory.getName(SourceSetNames.main, csVersion));
    mainSourceSet.java {
        srcDirs  = ['src/main/java'];
        if (!hasSonarQube) {
            excludes = ['**/sonarqube/**'];
        }
    }
    mainSourceSet.resources {
        srcDirs  = ['src/main/resources'];
    }

    // 'test' sourceSet
    SourceSet testSourceSet = project.sourceSets.create(nameFactory.getName(SourceSetNames.test, csVersion));
    testSourceSet.java {
        srcDirs  = ['src/test/java'];
        if (!hasSonarQube) {
            excludes = ['**/sonarqube/**'];
        }
    }
    testSourceSet.resources {
        srcDirs  = ['src/test/resources'];
    }
    testSourceSet.compileClasspath += files(mainSourceSet.output.classesDir);
    testSourceSet.compileClasspath += files(mainSourceSet.output.resourcesDir);
    testSourceSet.runtimeClasspath += files(mainSourceSet.output.classesDir);
    testSourceSet.runtimeClasspath += files(mainSourceSet.output.resourcesDir);
/*
    println "-- test";
    println 'compileConfigurationName = ' + sourceSets['test'].getCompileConfigurationName();
    println 'runtimeConfigurationName = ' + sourceSets['test'].getRuntimeConfigurationName();
    println 'output.classesDir = ' + sourceSets['test'].output.classesDir;
    println 'output.resourcesDir = ' + sourceSets['test'].output.resourcesDir;
    sourceSets['test'].java.each {println "java = " + it;}
    sourceSets['test'].compileClasspath.each {println 'compile = ' + it;}
    sourceSets['test'].runtimeClasspath.each {println 'runtime = ' + it;}

    println '-- test' + depVersions.Checkstyle;
    println 'compileConfigurationName = ' + sourceSets['test' + depVersions.Checkstyle].getCompileConfigurationName();
    println 'runtimeConfigurationName = ' + sourceSets['test' + depVersions.Checkstyle].getRuntimeConfigurationName();
    println 'output.classesDir = ' + sourceSets['test' + depVersions.Checkstyle].output.classesDir;
    println 'output.resourcesDir = ' + sourceSets['test' + depVersions.Checkstyle].output.resourcesDir;
    sourceSets['test' + depVersions.Checkstyle].java.each {println "java = " + it;}
    sourceSets['test' + depVersions.Checkstyle].compileClasspath.each {println 'compile = ' + it;}
    sourceSets['test' + depVersions.Checkstyle].runtimeClasspath.each {println 'runtime = ' + it;}

    //println sourceSets*.each { println it.name + ':\t' + it.output.classesDir };
    //println sourceSets*.each { println it.name + ':\t' + it.output.resourcesDir };
    println "--";
*/
    // 'provided' configuration
    Configuration providedConf = project.configurations.create(nameFactory.getName(ConfigNames.provided, csVersion));
    providedConf.setDescription("Provided classpath for source sets '${mainSourceSet.name}' and '${testSourceSet.name}'");

    // 'compile' configuration
    Configuration compileConf = nameFactory.getConfiguration(ConfigNames.mainCompile, csVersion);
    compileConf.setDescription("Compile classpath for source set '${mainSourceSet.name}'");

    // 'runtime' configuration
    Configuration runtimeConf = nameFactory.getConfiguration(ConfigNames.mainRuntime, csVersion);
    runtimeConf.setDescription("Runtime classpath for source set '${mainSourceSet.name}'");

    // 'testCompile' configuration
    Configuration testCompileConf = nameFactory.getConfiguration(ConfigNames.testCompile, csVersion);
    testCompileConf.setDescription("Compile classpath for source set '${testSourceSet.name}'");
    testCompileConf.extendsFrom(compileConf);

    // 'testRuntime' configuration (description text only)
    Configuration testRuntimeConf = nameFactory.getConfiguration(ConfigNames.testRuntime, csVersion);
    testRuntimeConf.setDescription("Runtime classpath for source set '${testSourceSet.name}'");

    // Dependencies
    addDependencies(depVersions, compileConf, testCompileConf, providedConf);
    mainSourceSet.compileClasspath += providedConf;
    mainSourceSet.runtimeClasspath += providedConf;
    testSourceSet.compileClasspath += providedConf;
    testSourceSet.runtimeClasspath += providedConf;

    // 'compileJava' task
    Task compileTask = nameFactory.getTask(TaskNames.compileJava, csVersion);
    compileTask.setDescription("${project.ext.longName}: ${compileTask.description} (Java level: ${depVersions.Java})");
    compileTask.setGroup(BasePlugin.BUILD_GROUP);
    compileTask.inputs.file(depCfgFile);

    // 'compileTestJava' task
    Task testCompileTask = nameFactory.getTask(TaskNames.compileTestJava, csVersion);
    testCompileTask.setDescription("${project.ext.longName}: ${testCompileTask.description} "
        + "(Java level: ${depVersions.Java})");
    testCompileTask.setGroup(BasePlugin.BUILD_GROUP);
    testCompileTask.dependsOn compileTask;
    testCompileTask.inputs.file(depCfgFile);

    // 'testClasses' task
    Task testClassesTask = nameFactory.getTask(TaskNames.testClasses, csVersion);
    testClassesTask.setDescription("${project.ext.longName}: ${testClassesTask.description}");
    testClassesTask.dependsOn nameFactory.getTask(TaskNames.mainClasses, csVersion);

    if (!isPublished) {
        return;  // no need for additional tasks if we don't publish for this Checkstyle version
    }

    // 'test' task
    Task testTask = project.tasks.create(name: nameFactory.getName(TaskNames.test, csVersion), type: Test);
    testTask.setDescription("${project.ext.longName}: Runs the unit tests in ${testSourceSet.name}.");
    testTask.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
    testTask.taskDependencies.each { TaskDependency tDep ->
        tDep.values = [nameFactory.getTask(TaskNames.mainClasses, csVersion), nameFactory.getTask(TaskNames.testClasses, csVersion)];
    }
    project.tasks.check.dependsOn testTask;
    testTask.testClassesDir = testSourceSet.output.classesDir;
    testTask.reports.html.setDestination(new File((File) project.reportsDir, testTask.name));
    testTask.reports.getJunitXml().enabled = false;
    testTask.classpath.getFrom().clear();
    testTask.classpath += files(testSourceSet.output.classesDir);
    testTask.classpath += files(testSourceSet.output.resourcesDir);
    testTask.classpath += files(mainSourceSet.output.classesDir);
    testTask.classpath += files(mainSourceSet.output.resourcesDir);
    testTask.classpath += files(testRuntimeConf.getFiles());
    testTask.classpath += files(providedConf.getFiles());
    testTask.configure {
        jacoco {
            enabled = false;
        }
        testLogging(configureTestLogging());
    }
    /*
    println '--- ' + testTask.name;
    println 'testClassesDir = ' + testTask.testClassesDir;
    println 'testSrcDirs = ' + testTask.testSrcDirs.collect { it; }
    println 'reports = ' + testTask.reports.html.entryPoint;
    println 'workingDir = ' + testTask.workingDir;
    testTask.classpath.each { println "classpath = " + it; }
    */

    [compileTask, testCompileTask].each { final JavaCompile pTask -> configureCompileTask(pTask, depVersions.Java); }

    // 'javadoc' task
    Javadoc javadocTask = (Javadoc) project.tasks.create(name: nameFactory.getName(TaskNames.javadoc, csVersion), type: Javadoc);
    javadocTask.setDescription("${project.ext.longName}: Generates Javadoc API documentation for the source " +
        "code in '${mainSourceSet.name}'.");
    javadocTask.setGroup(JavaBasePlugin.DOCUMENTATION_GROUP);
    javadocTask.dependsOn(compileTask);
    javadocTask.setSource(mainSourceSet.allJava);
    javadocTask.setDestinationDir(new File((File) project.docsDir, javadocTask.name));
    configureJavadocTask(javadocTask, mainSourceSet, depVersions.Java);
    if ('1.6'.equals(depVersions.Java)) {
        String javadoc6Exe = getJdk6Javadoc();
        if (javadoc6Exe == null) {
            throw new GradleException('ERROR: Property \'' + project.ext.javadoc6PropName +
                '\' not defined in gradle.properties. It must point to a Java 6 javadoc executable.');
        }
        javadocTask.setExecutable(javadoc6Exe);
    }
}
//println 'SourceSets: ' + (sourceSets.collect { it.name });



/*
 * Dependencies
 */
def void addDependencies(final Map<String, String> pDepVersions, final Configuration pCompileConf,
    final Configuration pTestCompileConf, final Configuration pProvidedConf)
{
    final boolean hasSonarQube = !"NOT_SUPPORTED".equals(pDepVersions.SonarQube);

    // provided
    Dependency fb1 = project.dependencies.create('com.google.code.findbugs:annotations:' + pDepVersions.FindBugs);
    Dependency fb2 = project.dependencies.create('com.google.code.findbugs:jsr305:' + pDepVersions.FindBugs);
    pProvidedConf.dependencies.add(fb1);
    pProvidedConf.dependencies.add(fb2);
    if (hasSonarQube) {
        Dependency sq = project.dependencies.create('org.codehaus.sonar:sonar-plugin-api:' + pDepVersions.SonarQube);
        pProvidedConf.dependencies.add(sq);
        if (!'NOT_SUPPORTED'.equals(pDepVersions.SQslf4jNop)) {
            Dependency slf4jNop = project.dependencies.create('org.slf4j:slf4j-nop:' + pDepVersions.SQslf4jNop);
            pProvidedConf.dependencies.add(slf4jNop);
        }
    }

    // compile
    Dependency csDep = project.dependencies.create('com.puppycrawl.tools:checkstyle:' + pDepVersions.Checkstyle);
    pCompileConf.dependencies.add(csDep);

    // testCompile
    Dependency junitDep = project.dependencies.create('junit:junit:4.11');
    pTestCompileConf.dependencies.add(junitDep);
}
project.configurations.create('provided');
addDependencies(project.ext.versionDefaults,
    project.configurations.compile, project.configurations.testCompile, project.configurations.provided);



/*
 * Set up cross-check feature. We provide an 'xcheck' task which depends on a number of Test tasks that run the
 * unit tests compiled against every Checkstyle version against all the other Checkstyle libraries. In this way, we
 * find out which versions are compatible.
 */
tasks.depConfigs.activeDepConfigs.each { final String depCfgToCheck ->

    final DependencyConfigsTask dcn = (DependencyConfigsTask) tasks.depConfigs;
    final Map<String, String> depVersionsToCheck = dcn.depVersions.get(depCfgToCheck);
    final String csVersionToCheck = depVersionsToCheck.Checkstyle;
    final NameFactory nameFactory = project.ext.nameFactory;
    if (!depVersionsToCheck.Published || depVersionsToCheck.TestAgainst.size() == 0) {
        return;
    }

    depVersionsToCheck.TestAgainst.each { final String depCfg4Cs ->
        if (depCfgToCheck.equals(depCfg4Cs)) {
            return;
        }

        final String csVersionRuntime = (dcn.depVersions.get(depCfg4Cs)).Checkstyle;

        Task xtestTask = project.tasks.create(
            name: nameFactory.getNameXCheck(csVersionToCheck, csVersionRuntime), type: Test);
        xtestTask.setDescription("${project.ext.longName}: Runs the unit tests for Checkstyle " +
            "${csVersionToCheck} against Checkstyle ${csVersionRuntime}.");
        xtestTask.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
        xtestTask.taskDependencies.each { TaskDependency tDep ->
            tDep.values = [nameFactory.getTask(TaskNames.mainClasses, csVersionToCheck),
                   nameFactory.getTask(TaskNames.testClasses, csVersionToCheck)];
        }

        SourceSet mainSourceSet = nameFactory.getSourceSet(SourceSetNames.main, csVersionToCheck);
        SourceSet testSourceSet = nameFactory.getSourceSet(SourceSetNames.test, csVersionToCheck);
        Configuration providedConf = nameFactory.getConfiguration(ConfigNames.provided, csVersionToCheck);
        Configuration testRuntimeConf = nameFactory.getConfiguration(ConfigNames.testRuntime, csVersionRuntime);

        xtestTask.testClassesDir = testSourceSet.output.classesDir;
        xtestTask.reports.getHtml().enabled = false;
        xtestTask.reports.getJunitXml().enabled = false;
        xtestTask.classpath.getFrom().clear();
        xtestTask.classpath += files(testSourceSet.output.classesDir);
        xtestTask.classpath += files(testSourceSet.output.resourcesDir);
        xtestTask.classpath += files(mainSourceSet.output.classesDir);
        xtestTask.classpath += files(mainSourceSet.output.resourcesDir);
        xtestTask.classpath += files(testRuntimeConf.getFiles());
        xtestTask.classpath += files(providedConf.getFiles());
        xtestTask.configure {
            jacoco {
                enabled = false;
            }
            testLogging {
                events = [];
            }
        }
    }
}
task xcheck {
    setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
    setDescription("${project.ext.longName}: Runs the unit tests against other Checkstyle versions " +
        "which they were not compiled for");
    dependsOn tasks.check;
    Set<Task> xtestTasks = tasks.findAll { final Task t -> t.name.startsWith('xtest'); };
    xtestTasks.each { dependsOn it; }
}
tasks.build.dependsOn tasks.xcheck;



/*
 * Remove superfluous Checkstyle tasks that were created for our additional source sets. We only run Checkstyle on the
 * 'main' and 'test' source sets. The Checkstyle plugin is configured to do that below, but it still creates these
 * undead tasks. So we clean up after it by removing them.
 */
project.tasks.withType(Checkstyle) { Task task ->
    if (!"checkstyleMain".equals(task.name) && !"checkstyleTest".equals(task.name)) {
        project.tasks.remove(task);
    }
}



def String getJdk6Compiler()
{
    String result = System.getenv((String) project.ext.jdk6PropName);
    if (project.hasProperty((String) project.ext.jdk6PropName)) {
        result = project.property((String) project.ext.jdk6PropName);
    }
    return result;
}

def String getJdk6Javadoc()
{
    String result = System.getenv((String) project.ext.javadoc6PropName);
    if (project.hasProperty((String) project.ext.javadoc6PropName)) {
        result = project.property((String) project.ext.javadoc6PropName);
    }
    return result;
}

def void configureCompileTask(final JavaCompile pTask, final String pJavaLevel)
{
    pTask.sourceCompatibility = pJavaLevel;
    pTask.targetCompatibility = pJavaLevel;
    pTask.options.encoding = 'UTF-8';
    pTask.options.deprecation = true;

    // The warning "Supported source version 'RELEASE_6' from annotation processor 'org.antlr.v4.runtime.misc.
    // NullUsageProcessor' less than -source '1.7'" is okay and may be ignored. It goes away when Checkstyle
    // updates to ANTLR 4.5: https://github.com/antlr/antlr4/issues/487 (which they did in version 6.5)

    if ('1.6'.equals(pJavaLevel)) {
        pTask.options.fork = true;
        def javac6 = getJdk6Compiler();
        if (javac6 == null) {
            throw new GradleException('ERROR: Property \'' + project.ext.jdk6PropName +
                '\' not defined in gradle.properties. It must point to a Java 6 compiler executable.');
        }
        pTask.options.forkOptions.executable = javac6;
    }
}



[tasks.compileJava, tasks.compileTestJava].each { final JavaCompile pTask ->
    configureCompileTask(pTask, (String) versionDefaults.Java);
}

sourceSets.main.compileClasspath += configurations.provided;
sourceSets.main.runtimeClasspath += configurations.provided;
sourceSets.test.compileClasspath += configurations.provided;
sourceSets.test.runtimeClasspath += configurations.provided;



/*
 * Configure IntelliJ IDEA
 */
idea.project {
    languageLevel = project.ext.versionDefaults.Java;
    // TODO set file encoding to UTF-8
    // example: http://mrhaki.blogspot.de/2012/09/gradle-goodness-customize-idea-project.html
}
idea.module {
    downloadSources = true;
    downloadJavadoc = true;
    excludeDirs += file('.idea');
    excludeDirs += file('_site');
    excludeDirs += file('_support');
    scopes.PROVIDED.plus += [configurations.provided];
}



/*
 * Javadoc generation
 */
javadoc {
    configureJavadocTask(tasks.javadoc, project.sourceSets.main, project.ext.versionDefaults.Java);
}
def void configureJavadocTask(final Javadoc pTask, final SourceSet pMainSourceSet, final String pJavaLevel)
{
    pTask.title = project.ext.longName + ' v' + project.version;
    pTask.classpath = pMainSourceSet.compileClasspath;
    pTask.options.encoding = 'UTF-8';
    pTask.options.docEncoding = 'UTF-8';
    pTask.options.charSet = 'UTF-8';
    pTask.options.author = true;
    pTask.options.use = true;
    pTask.options.windowTitle = project.ext.longName;
    pTask.options.splitIndex = false;
    pTask.options.outputLevel = null;   // specify neither -quiet nor -verbose
    pTask.options.header = project.ext.longName;
    if ('1.7'.equals(pJavaLevel)) {
        pTask.options.links('https://jsr-305.googlecode.com/svn/trunk/javadoc/',
            'http://docs.oracle.com/javase/7/docs/api/',
            'http://javadocs.sonarsource.org/3.0/apidocs/',
            'http://checkstyle.sourceforge.net/apidocs/');
    } else if ('1.6'.equals(pJavaLevel)) {
        pTask.options.links('https://jsr-305.googlecode.com/svn/trunk/javadoc/',
            'http://docs.oracle.com/javase/6/docs/api/',
            'http://javadocs.sonarsource.org/3.0/apidocs/',
            'http://checkstyle.sourceforge.net/apidocs/');
    }

    // javadoc does not inherit the proxy settings (https://issues.gradle.org/browse/GRADLE-1228)
    if (System.properties['http.proxyHost'] != null) {
        pTask.options.jFlags('-DproxyHost=' + System.properties['http.proxyHost'],
            '-DproxyPort=' + System.properties['http.proxyPort'],
            '-DproxyUser=' + System.properties['http.proxyUser'],
            '-DproxyPassword=' + System.properties['http.proxyPassword']);
    }
}

/*
 * Checkstyle configuration
 */
checkstyle {
    configFile file('project/checkstyle.xml');
    configProperties 'projectDir': project.projectDir;
    sourceSets = [project.sourceSets.main, project.sourceSets.test];
    toolVersion '6.10.1';  // depends on our checkstyle.xml; has nothing to do with the version used for building
    showViolations = true;
    ignoreFailures = false;
}


/*
 * JaCoCo test coverage configuration
 */
final Test realTest = (Test) project.tasks['test'];
realTest.dependsOn(tasks.testClasses);
realTest.classpath += files((File) project.sourceSets.test.output.classesDir);
realTest.classpath += files((File) project.sourceSets.test.output.resourcesDir);
realTest.classpath += files((File) project.sourceSets.main.output.classesDir);
realTest.classpath += files((File) project.sourceSets.main.output.resourcesDir);
realTest.classpath += files((Set<File>) project.configurations['testRuntime'].getFiles());
String[] excludedClasses = ['**/com/thomasjensen/checkstyle/addons/util/CheckstyleApiFixer*'];
test {
    jacoco {
        append = false;
        excludes = excludedClasses;
    }
    testLogging(configureTestLogging());
    jacocoTestReport {
        reports {
            html.enabled = true;
            xml.enabled = true;     // coveralls plugin depends on xml format report
            csv.enabled = false;
        }
        doFirst {
            classDirectories = fileTree(dir: sourceSets.main.output.classesDir).exclude(excludedClasses);
        }
    }
}


def Closure configureTestLogging()
{
    return {
        events 'failed';
        showStackTraces = true;
        showExceptions = true;
        showCauses = true;
        showStandardStreams = true;
        exceptionFormat 'full';
    };
}


def String readVersionProps()
{
    final File versionFile = new File("project/version.properties");
    def props = new Properties();
    versionFile.withInputStream {
        InputStream stream -> props.load(stream);
    }

    final StringBuilder sb = new StringBuilder();
    sb.append(props.getProperty('major'));
    sb.append('.');
    sb.append(props.getProperty('minor'));
    sb.append('.');
    sb.append(props.getProperty('patch'));
    if (!Boolean.parseBoolean(props.getProperty('release'))) {
        sb.append('-SNAPSHOT');
    }

    final String v = sb.toString();
    System.out.println('Building version: ' + v);
    return v;
}



/*
 * Packaging of documentation for publication on the website
 */
apply from: 'site.gradle';

/*
 * Publishing of artifacts
 */
apply from: 'publish.gradle';

/*
 * Creation of the individual JARs produced by this project
 */
apply from: 'artifacts.gradle';
